<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CloudFlixx TV</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-oHDEc8Xed2gFunf/7yA+EtRbvnoUhI6be9zE+R6a4pQqI0ErwHJ1HkGSpCUHUCm5jNFlVxUC0rBPChLw8Fdw3A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    body {
      margin: 0;
      background: #121212;
      color: #fff;
      font-family: Arial, sans-serif;
      overflow-x: hidden;
    }
    #player-container {
      max-width: 1000px;
      margin: 20px auto;
      background: #1e1e1e;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    #video-wrapper {
      position: relative;
      border-radius: 8px;
      overflow: hidden;
    }
    video {
      width: 100%;
      display: block;
      background: #000;
    }
    #metrics-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 8px 12px;
      border-radius: 4px;
      display: flex;
      gap: 12px;
      font-size: 14px;
      align-items: center;
    }
    #metrics-panel span {
      display: flex;
      align-items: center;
    }
    /* Example inline SVG icon for network status */
    .network-icon {
      width: 16px;
      height: 16px;
      margin-right: 4px;
      fill: #4caf50;
    }
    #controls {
      margin-top: 15px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    select, button {
      background: #333;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
    }
    select:focus, button:focus {
      outline: none;
    }
    button:hover {
      background: #444;
      cursor: pointer;
    }
    /* Channel list styles */
    #channel-browser {
      margin-top: 20px;
    }
    #channel-filters {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    #search-box {
      flex-grow: 1;
      background: #333;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
    }
    #category-selector {
      min-width: 150px;
    }
    #channel-list-container {
      max-height: 400px;
      overflow-y: auto;
      background: #2a2a2a;
      border-radius: 8px;
      padding: 5px;
      margin-top: 10px;
    }
    .channel-item {
      display: flex;
      padding: 8px 10px;
      border-bottom: 1px solid #3a3a3a;
      cursor: pointer;
      align-items: center;
    }
    .channel-item:hover {
      background: #3a3a3a;
    }
    .channel-item.active {
      background: #444;
    }
    .channel-logo {
      width: 40px;
      height: 24px;
      background: #333;
      margin-right: 10px;
      object-fit: contain;
    }
    .channel-name {
      flex-grow: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .channel-category {
      font-size: 12px;
      color: #aaa;
      margin-left: 8px;
      background: #333;
      padding: 2px 6px;
      border-radius: 10px;
    }
    .loading-indicator {
      text-align: center;
      padding: 20px;
      color: #aaa;
    }
    #status-message {
      padding: 10px;
      margin-top: 10px;
      border-radius: 4px;
      display: none;
    }
    #status-message.error {
      background: rgba(255, 0, 0, 0.2);
      color: #ff9999;
      display: block;
    }
    #status-message.success {
      background: rgba(0, 255, 0, 0.2);
      color: #99ff99;
      display: block;
    }
    #address-input {
      flex-grow: 1;
      background: #333;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
    }
    .no-results {
      padding: 20px;
      text-align: center;
      color: #aaa;
    }
    #channel-count {
      background: #333;
      padding: 4px 8px;
      border-radius: 4px;
      margin-left: 10px;
      font-size: 12px;
    }
    .header {
      text-align: center;
      padding: 20px 0;
      background: linear-gradient(to right, #000000, #1e1e1e);
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .logo {
      color: #e50914;
      font-size: 2.5em;
      font-weight: bold;
      margin: 0;
      letter-spacing: 2px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <div class="header">
    <h1 class="logo">CLOUDFLIXX TV</h1>
  </div>
  <div id="player-container">
    <div id="video-wrapper">
      <video id="video-player" controls autoplay></video>
      <div id="metrics-panel">
        <span id="buffer-metric">
          <strong>Buffer:</strong> <span id="buffer-length">0</span>s
        </span>
        <span id="quality-metric">
          <strong>Quality:</strong> <span id="quality-level">Auto</span>
        </span>
        <span id="network-status">
          <svg class="network-icon" viewBox="0 0 24 24">
            <path d="M12 20c.55 0 1-.45 1-1v-2h-2v2c0 .55.45 1 1 1zm7.07-3.93c.39.39 1.02.39 1.41 0s.39-1.02 0-1.41l-1.43-1.43c.64-.84 1.03-1.88 1.03-3.13 0-2.76-2.24-5-5-5-1.25 0-2.29.39-3.13 1.03L9.5 7.5c-.39.39-1.02.39-1.41 0s-.39-1.02 0-1.41l1.43-1.43C8.29 3.39 7.25 3 6 3 2.69 3 0 5.69 0 9c0 1.25.39 2.29 1.03 3.13L-.4 13.56c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0l1.43-1.43C3.71 16.61 4.75 17 6 17c2.76 0 5-2.24 5-5 0-1.25-.39-2.29-1.03-3.13l1.43-1.43c.39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0L8.97 7.97C8.33 7.13 7.94 6.09 7.94 4.84c0-2.76 2.24-5 5-5 1.25 0 2.29.39 3.13 1.03l1.43-1.43c.39-.39 1.02-.39 1.41 0 .39.39.39 1.02 0 1.41l-1.43 1.43C19.61 3.71 20 4.75 20 6c0 2.76-2.24 5-5 5-1.25 0-2.29-.39-3.13-1.03l-1.43 1.43c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0l1.43-1.43C13.71 14.61 14.75 15 16 15c2.31 0 4-1.69 4-4 0-1.25-.39-2.29-1.03-3.13L21.07 8.07c.39.39.39 1.02 0 1.41-.39.39-1.02.39-1.41 0l-1.43-1.43C18.61 9.71 19 10.75 19 12c0 1.25-.39 2.29-1.03 3.13l1.43 1.43z"/>
          </svg>
          <strong>Network:</strong> <span id="network-condition">Good</span>
        </span>
      </div>
    </div>
    <div id="controls">
      <input type="text" id="address-input" placeholder="Enter M3U playlist URL" value="https://iptv-org.github.io/iptv/index.m3u" readonly>
      <button id="load-address">Load Playlist</button>
      <select id="quality-selector">
        <option value="auto">Auto</option>
        <option value="240">240p</option>
        <option value="360">360p</option>
        <option value="480">480p</option>
        <option value="720">720p</option>
        <option value="1080">1080p</option>
      </select>
    </div>
    
    <div id="status-message"></div>
    
    <div id="channel-browser">
      <div id="channel-filters">
        <input type="text" id="search-box" placeholder="Search channels...">
        <select id="category-selector">
          <option value="all">All Categories</option>
        </select>
        <span id="channel-count">0 channels</span>
      </div>
      <div id="channel-list-container">
        <div class="loading-indicator" id="loading-indicator">Loading channels...</div>
        <div id="channel-list"></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script>
    const video = document.getElementById('video-player');
    const qualitySelector = document.getElementById('quality-selector');
    const bufferLengthEl = document.getElementById('buffer-length');
    const qualityLevelEl = document.getElementById('quality-level');
    const networkConditionEl = document.getElementById('network-condition');
    const addressInput = document.getElementById('address-input');
    const loadAddressBtn = document.getElementById('load-address');
    const searchBox = document.getElementById('search-box');
    const categorySelector = document.getElementById('category-selector');
    const channelListContainer = document.getElementById('channel-list-container');
    const channelList = document.getElementById('channel-list');
    const loadingIndicator = document.getElementById('loading-indicator');
    const statusMessage = document.getElementById('status-message');
    const channelCount = document.getElementById('channel-count');

    let hls;
    let channels = [];
    let activeChannel = null;
    let categories = new Set(['all']);
    let filteredChannels = [];
    let retryCount = 0;
    let maxRetries = 5;
    let currentStreamUrl = '';
    
    // Enhanced buffer settings
    const bufferSettings = {
      standard: {
        maxBufferLength: 180,      // 3 minutes
        maxMaxBufferLength: 300,   // 5 minutes
      },
      aggressive: {
        maxBufferLength: 360,      // 6 minutes
        maxMaxBufferLength: 540,   // 9 minutes
      },
      extreme: {
        maxBufferLength: 540,      // 9 minutes
        maxMaxBufferLength: 600,   // 10 minutes
      }
    };
    
    let currentBufferMode = 'aggressive'; // Default to aggressive buffering

    // Initialize video player with HLS support and custom buffering config
    function initPlayer(streamUrl) {
      if (!streamUrl) {
        showStatusMessage('Please enter a valid stream URL', 'error');
        return;
      }

      currentStreamUrl = streamUrl;
      retryCount = 0;
      
      try {
        if (hls) {
          hls.destroy();
          hls = null;
        }
        
        if (Hls.isSupported()) {
          const bufferConfig = bufferSettings[currentBufferMode];
          
          hls = new Hls({
            maxBufferLength: bufferConfig.maxBufferLength,
            maxMaxBufferLength: bufferConfig.maxMaxBufferLength,
            maxBufferSize: 300 * 1000 * 1000, // 300MB buffer size
            maxBufferHole: 0.5,               // More aggressive hole filling
            highBufferWatchdogPeriod: 5,      // More frequent buffer checking
            enableWorker: true,
            fragLoadingMaxRetry: 15,          // More retries for fragments
            manifestLoadingMaxRetry: 15,      // More retries for manifest
            levelLoadingMaxRetry: 15,         // More retries for levels
            fragLoadingRetryDelay: 500,       // Start retry delay at 500ms
            manifestLoadingRetryDelay: 500,   // Start retry delay at 500ms
            levelLoadingRetryDelay: 500,      // Start retry delay at 500ms
            fragLoadingMaxRetryTimeout: 10000, // Max retry delay 10s
            manifestLoadingMaxRetryTimeout: 10000, // Max retry delay 10s
            levelLoadingMaxRetryTimeout: 10000, // Max retry delay 10s
            startLevel: -1,                   // Auto start level
            abrEwmaDefaultEstimate: 5000000,  // 5Mbps starting bandwidth estimate
            abrBandWidthFactor: 0.8,          // Slightly conservative ABR
            abrBandWidthUpFactor: 0.7,        // Slightly conservative ABR up factor
            lowLatencyMode: false,            // Disable low latency mode for better buffering
            capLevelToPlayerSize: false,      // Allow any resolution
            debug: false                      // Set to true for debugging
          });
          
          // Force specific format if needed (for problem streams)
          if (streamUrl.includes('.m3u8')) {
            streamUrl = streamUrl + '?format=mpegts';
          }
          
          hls.loadSource(streamUrl);
          hls.attachMedia(video);
          
          hls.on(Hls.Events.MANIFEST_PARSED, function() {
            // Ready for playback
            console.log('Stream parsed and ready for playback');
            
            // Force autoplay with multiple attempts
            const playPromise = video.play();
            if (playPromise !== undefined) {
              playPromise.catch(error => {
                console.warn('Autoplay failed:', error);
                // Try again with muted if needed
                video.muted = true;
                video.play().then(() => {
                  showStatusMessage('Stream started muted (click for sound)', 'success');
                  // Let user unmute with click
                  video.addEventListener('click', () => {
                    if (video.muted) {
                      video.muted = false;
                    }
                  }, { once: true });
                }).catch(e => {
                  console.error('Muted autoplay also failed:', e);
                  showStatusMessage('Tap to start playback', 'error');
                });
              });
            }
            
            showStatusMessage('Stream loaded successfully', 'success');
            setTimeout(() => {
              statusMessage.style.display = 'none';
            }, 3000);
          });
          
          hls.on(Hls.Events.FRAG_BUFFERED, function(event, data) {
            // Update buffer metrics
            updateMetrics();
          });
          
          hls.on(Hls.Events.ERROR, function(event, data) {
            console.warn('HLS error:', data);
            
            if (data.fatal) {
              switch(data.type) {
                case Hls.ErrorTypes.NETWORK_ERROR:
                  showStatusMessage('Network error, recovering...', 'error');
                  
                  // Escalate buffer settings on network errors
                  if (currentBufferMode === 'standard') {
                    currentBufferMode = 'aggressive';
                  } else if (currentBufferMode === 'aggressive') {
                    currentBufferMode = 'extreme';
                  }
                  
                  if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`Retry attempt ${retryCount}/${maxRetries} with ${currentBufferMode} buffering`);
                    
                    // Add delay before retry for network to recover
                    setTimeout(() => {
                      hls.destroy();
                      initPlayer(currentStreamUrl);
                    }, 2000);
                  } else {
                    // Try a different approach if too many retries
                    showStatusMessage('Maximum retries reached. Trying alternative method...', 'error');
                    
                    // Try reloading with http-reload query parameter
                    if (currentStreamUrl.includes('?')) {
                      currentStreamUrl += '&http-reload=true';
                    } else {
                      currentStreamUrl += '?http-reload=true';
                    }
                    
                    setTimeout(() => {
                      hls.destroy();
                      initPlayer(currentStreamUrl);
                      retryCount = 0; // Reset retry counter for new attempt
                    }, 2000);
                  }
                  break;
                case Hls.ErrorTypes.MEDIA_ERROR:
                  showStatusMessage('Media error, recovering...', 'error');
                  hls.recoverMediaError();
                  break;
                default:
                  if (retryCount < maxRetries) {
                    retryCount++;
                    showStatusMessage(`Fatal error: ${data.details}, retrying...`, 'error');
                    
                    // Destroy and recreate for severe errors
                    setTimeout(() => {
                      hls.destroy();
                      initPlayer(currentStreamUrl);
                    }, 2000);
                  } else {
                    showStatusMessage(`Could not play stream after multiple attempts`, 'error');
                  }
                  break;
              }
            } else {
              // Non-fatal errors just log
              console.log('Non-fatal HLS error:', data.details);
            }
          });
          
          hls.on(Hls.Events.LEVEL_SWITCHED, function(event, data) {
            const level = hls.levels[data.level];
            qualityLevelEl.textContent = level ? level.height + 'p' : 'Auto';
          });
        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
          // Native HLS support (Safari)
          video.src = streamUrl;
          video.addEventListener('loadedmetadata', () => {
            const playPromise = video.play();
            if (playPromise !== undefined) {
              playPromise.catch(error => {
                console.warn('Autoplay failed:', error);
                // Try again with muted
                video.muted = true;
                video.play().catch(e => {
                  console.error('Muted autoplay also failed:', e);
                });
              });
            }
            console.log('Native HLS support: stream loaded');
          });
          
          // Add error handling for native player
          video.addEventListener('error', (e) => {
            console.error('Video error:', video.error);
            showStatusMessage(`Playback error: ${video.error.message || 'Unknown error'}`, 'error');
            
            if (retryCount < maxRetries) {
              retryCount++;
              setTimeout(() => {
                video.src = streamUrl;
                video.load();
                video.play().catch(err => console.warn('Retry play failed:', err));
              }, 2000);
            }
          });
        } else {
          showStatusMessage('HLS playback not supported in this browser', 'error');
        }
      } catch (e) {
        console.error('Player initialization error:', e);
        showStatusMessage('Failed to initialize player: ' + e.message, 'error');
      }
    }

    // Parse M3U playlist with improved error handling
    async function parseM3UPlaylist(url) {
      showStatusMessage('Loading playlist...', 'success');
      channelListContainer.style.display = 'block';
      loadingIndicator.style.display = 'block';
      channelList.innerHTML = '';
      
      // Reset categories
      categories = new Set(['all']);
      categorySelector.innerHTML = '<option value="all">All Categories</option>';
      
      try {
        // Try with CORS proxy if direct fetch fails
        let content;
        let response;
        
        try {
          response = await fetch(url, { 
            cache: 'no-store',
            headers: {
              'Accept': 'application/x-mpegURL, application/vnd.apple.mpegurl, */*'
            },
            mode: 'cors'
          });
        } catch (e) {
          console.warn('Direct fetch failed, trying alternative method:', e);
          // Try using a CORS proxy (you might need to set up your own or use a public one)
          const corsProxyUrl = 'https://api.allorigins.win/raw?url=';
          response = await fetch(corsProxyUrl + encodeURIComponent(url), {
            cache: 'no-store'
          });
        }
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        content = await response.text();
        
        // Check if content is valid M3U
        if (!content.trim().startsWith('#EXTM3U')) {
          // Try to fix malformed M3U files
          if (content.includes('#EXTINF:') && !content.includes('#EXTM3U')) {
            content = '#EXTM3U\n' + content;
          } else {
            throw new Error('Invalid M3U playlist format');
          }
        }
        
        const lines = content.split('\n');
        
        let parsedChannels = [];
        let currentChannel = null;
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          
          if (line.startsWith('#EXTINF:')) {
            // Channel info line
            currentChannel = {
              name: '',
              logo: '',
              url: '',
              category: 'Uncategorized',
              info: line
            };
            
            // Extract channel name
            const nameMatch = line.match(/tvg-name="([^"]*)"/) || line.match(/,(.*)$/);
            if (nameMatch && nameMatch[1]) {
              currentChannel.name = nameMatch[1].trim();
            }
            
            // Extract logo if available
            const logoMatch = line.match(/tvg-logo="([^"]*)"/);
            if (logoMatch && logoMatch[1]) {
              currentChannel.logo = logoMatch[1];
            }
            
            // Extract category
            currentChannel.category = extractCategory(line);
            categories.add(currentChannel.category);
          } else if (line && !line.startsWith('#') && currentChannel) {
            // This is the URL line (channel stream)
            currentChannel.url = line;
            
            // Only add channels that have a valid URL
            if (currentChannel.url) {
              // If name is missing, use URL as name
              if (!currentChannel.name) {
                const urlParts = currentChannel.url.split('/');
                currentChannel.name = `Channel ${parsedChannels.length + 1}`;
              }
              
              parsedChannels.push(currentChannel);
              currentChannel = null;
            }
          }
        }
        
        channels = parsedChannels;
        populateCategorySelector();
        filterChannels();
        
        if (parsedChannels.length === 0) {
          showStatusMessage('No channels found in the playlist', 'error');
        } else {
          showStatusMessage(`Loaded ${parsedChannels.length} channels`, 'success');
          channelCount.textContent = `${parsedChannels.length} channels`;
          setTimeout(() => {
            statusMessage.style.display = 'none';
          }, 3000);
        }
      } catch (error) {
        console.error('Error loading M3U playlist:', error);
        showStatusMessage('Failed to load playlist: ' + error.message, 'error');
        loadingIndicator.style.display = 'none';
      }
    }

    // Update playback metrics every second with improved buffer calculation
    function updateMetrics() {
      let bufferLength = 0;
      
      // Get accurate buffer information
      if (hls && hls.media && hls.media.buffered.length) {
        const currentTime = hls.media.currentTime;
        let maxBufferEnd = 0;
        
        // Find the largest buffered end time
        for (let i = 0; i < hls.media.buffered.length; i++) {
          if (hls.media.buffered.start(i) <= currentTime && 
              hls.media.buffered.end(i) >= currentTime &&
              hls.media.buffered.end(i) > maxBufferEnd) {
            maxBufferEnd = hls.media.buffered.end(i);
          }
        }
        
        if (maxBufferEnd > 0) {
          bufferLength = maxBufferEnd - currentTime;
        }
      } else if (video.buffered.length) {
        const currentTime = video.currentTime;
        for (let i = 0; i < video.buffered.length; i++) {
          if (video.buffered.start(i) <= currentTime && video.buffered.end(i) >= currentTime) {
            bufferLength = video.buffered.end(i) - currentTime;
            break;
          }
        }
      }
      
      bufferLengthEl.textContent = Math.floor(bufferLength);
      
      // Network condition based on buffer health
      if (bufferLength > 60) { // More than 1 minute
        networkConditionEl.textContent = 'Excellent';
        document.querySelector('.network-icon').style.fill = '#4caf50'; // Green
      } else if (bufferLength > 30) { // 30-60 seconds
        networkConditionEl.textContent = 'Good';
        document.querySelector('.network-icon').style.fill = '#8bc34a'; // Light green
      } else if (bufferLength > 10) { // 10-30 seconds
        networkConditionEl.textContent = 'Fair';
        document.querySelector('.network-icon').style.fill = '#ffc107'; // Yellow
      } else if (bufferLength > 3) { // 3-10 seconds
        networkConditionEl.textContent = 'Poor';
        document.querySelector('.network-icon').style.fill = '#ff9800'; // Orange
      } else {
        networkConditionEl.textContent = 'Critical';
        document.querySelector('.network-icon').style.fill = '#f44336'; // Red
      }
      
      // Adaptive buffer mode based on network conditions
      if (hls && bufferLength < 5 && currentBufferMode !== 'extreme') {
        // Switch to extreme buffering when buffer is critically low
        currentBufferMode = 'extreme';
        console.log('Switching to extreme buffering mode');
        // Apply new settings without reinitializing to avoid interruption
        hls.config.maxBufferLength = bufferSettings.extreme.maxBufferLength;
        hls.config.maxMaxBufferLength = bufferSettings.extreme.maxMaxBufferLength;
      } else if (hls && bufferLength > 60 && currentBufferMode === 'extreme') {
        // Switch back to aggressive mode when buffer is healthy
        currentBufferMode = 'aggressive';
        console.log('Switching to aggressive buffering mode');
        hls.config.maxBufferLength = bufferSettings.aggressive.maxBufferLength;
        hls.config.maxMaxBufferLength = bufferSettings.aggressive.maxMaxBufferLength;
      }
    }
    setInterval(updateMetrics, 1000);

    // Handle quality changes
    qualitySelector.addEventListener('change', () => {
      if (!hls) return;
      
      const qualityValue = qualitySelector.value;
      qualityLevelEl.textContent = qualityValue === 'auto' ? 'Auto' : qualityValue + 'p';
      
      if (qualityValue === 'auto') {
        hls.currentLevel = -1; // Auto
      } else {
        // Find the closest matching quality level
        const targetHeight = parseInt(qualityValue);
        let closestLevel = 0;
        let closestDiff = Number.MAX_VALUE;
        
        for (let i = 0; i < hls.levels.length; i++) {
          const diff = Math.abs(hls.levels[i].height - targetHeight);
          if (diff < closestDiff) {
            closestDiff = diff;
            closestLevel = i;
          }
        }
        
        hls.currentLevel = closestLevel;
      }
    });

    // Load M3U playlist
    loadAddressBtn.addEventListener('click', () => {
      const url = addressInput.value.trim();
      if (url) {
        parseM3UPlaylist(url);
      } else {
        showStatusMessage('Please enter a valid M3U playlist URL', 'error');
      }
    });

    // Handle Enter key press in address input
    addressInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        loadAddressBtn.click();
      }
    });

    // Search and filter channels
    searchBox.addEventListener('input', filterChannels);
    categorySelector.addEventListener('change', filterChannels);

    const defaultPlaylistUrl = 'https://iptv-org.github.io/iptv/index.m3u';
    addressInput.value = defaultPlaylistUrl;

    // Load the default playlist when page loads
    window.addEventListener('DOMContentLoaded', () => {
      parseM3UPlaylist(defaultPlaylistUrl);
    });

    // Extract category from channel info
    function extractCategory(channelInfo) {
      // Try to extract from group-title attribute
      const groupMatch = channelInfo.match(/group-title="([^"]*)"/);
      if (groupMatch && groupMatch[1]) {
        return groupMatch[1].trim();
      }
      
      // Try to extract from tvg-genre attribute
      const genreMatch = channelInfo.match(/tvg-genre="([^"]*)"/);
      if (genreMatch && genreMatch[1]) {
        return genreMatch[1].trim();
      }
      
      return 'Uncategorized';
    }

    // Populate category selector with available categories
    function populateCategorySelector() {
      categorySelector.innerHTML = '<option value="all">All Categories</option>';
      
      // Sort categories alphabetically
      const sortedCategories = Array.from(categories).sort();
      
      sortedCategories.forEach(category => {
        if (category !== 'all') {
          const option = document.createElement('option');
          option.value = category;
          option.textContent = category;
          categorySelector.appendChild(option);
        }
      });
    }

    // Filter channels based on search and category
    function filterChannels() {
      const searchTerm = searchBox.value.toLowerCase();
      const selectedCategory = categorySelector.value;
      
      filteredChannels = channels.filter(channel => {
        const matchesSearch = channel.name.toLowerCase().includes(searchTerm);
        const matchesCategory = selectedCategory === 'all' || channel.category === selectedCategory;
        return matchesSearch && matchesCategory;
      });
      
      renderChannelList();
      
      // Update channel count
      channelCount.textContent = `${filteredChannels.length} channels`;
    }

    // Render channel list to the DOM
    function renderChannelList() {
      loadingIndicator.style.display = 'none';
      channelList.innerHTML = '';
      
      if (filteredChannels.length === 0) {
        channelList.innerHTML = '<div class="no-results">No channels match your search</div>';
        return;
      }
      
      filteredChannels.forEach((channel, index) => {
        const channelElement = document.createElement('div');
        channelElement.className = 'channel-item';
        channelElement.setAttribute('data-index', index);
        
        let channelHtml = '';
        
        if (channel.logo) {
          channelHtml += `<img src="${channel.logo}" class="channel-logo" onerror="this.style.display='none'">`;
        }
        
        channelHtml += `<div class="channel-name">${channel.name}</div>`;
        channelHtml += `<div class="channel-category">${channel.category}</div>`;
        channelElement.innerHTML = channelHtml;
        
        channelElement.addEventListener('click', () => {
          selectChannel(index);
        });
        
        channelList.appendChild(channelElement);
      });
      
      // Auto-select first channel if no channel is currently active
      if (filteredChannels.length > 0 && !activeChannel) {
        selectChannel(0);
      }
    }

    // Select and load a channel
    function selectChannel(index) {
      const channel = filteredChannels[index];
      
      if (!channel || !channel.url) {
        showStatusMessage('Invalid channel or stream URL', 'error');
        return;
      }
      
      // Update active channel in UI
      document.querySelectorAll('.channel-item').forEach(el => {
        el.classList.remove('active');
      });
      
      const channelElement = document.querySelector(`.channel-item[data-index="${index}"]`);
      if (channelElement) {
        channelElement.classList.add('active');
        // Scroll to make selected channel visible if needed
        channelElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
      
      activeChannel = channel;
      initPlayer(channel.url);
    }

    // Show status message
    function showStatusMessage(message, type) {
      statusMessage.textContent = message;
      statusMessage.className = '';
      statusMessage.classList.add(type);
      statusMessage.style.display = 'block';
    }
  </script>
</body>
</html>